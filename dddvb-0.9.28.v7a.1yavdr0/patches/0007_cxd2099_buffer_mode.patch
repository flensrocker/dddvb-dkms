diff -Naur dddvb-0.9.28.v7a.0yavdr0_sav/frontends/cxd2099.c dddvb-0.9.28.v7a.0yavdr0/frontends/cxd2099.c
--- dddvb-0.9.28.v7a.0yavdr0_sav/frontends/cxd2099.c	2017-03-17 20:53:46.000000000 +0100
+++ dddvb-0.9.28.v7a.0yavdr0/frontends/cxd2099.c	2017-05-07 13:10:29.000000000 +0200
@@ -22,12 +22,9 @@
  * Or, point your browser to http://www.gnu.org/copyleft/gpl.html
  */
 
-#include <linux/version.h>
 #include <linux/slab.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
-#include <linux/moduleparam.h>
-#include <linux/init.h>
 #include <linux/i2c.h>
 #include <linux/wait.h>
 #include <linux/delay.h>
@@ -36,7 +33,9 @@
 
 #include "cxd2099.h"
 
-//#define BUFFER_MODE 1
+#ifndef BUFFER_MODE
+#define BUFFER_MODE 1
+#endif
 
 static int read_data(struct dvb_ca_en50221 *ca, int slot, u8 *ebuf, int ecount);
 
@@ -73,8 +72,9 @@
 	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = m, .len = 2};
 
 	if (i2c_transfer(adapter, &msg, 1) != 1) {
-		pr_err("Failed to write to I2C register %02x@%02x!\n",
-		       reg, adr);
+		dev_err(&adapter->dev,
+			"Failed to write to I2C register %02x@%02x!\n",
+			reg, adr);
 		return -1;
 	}
 	return 0;
@@ -86,7 +86,7 @@
 	struct i2c_msg msg = {.addr = adr, .flags = 0, .buf = data, .len = len};
 
 	if (i2c_transfer(adapter, &msg, 1) != 1) {
-		pr_err("Failed to write to I2C!\n");
+		dev_err(&adapter->dev, "Failed to write to I2C!\n");
 		return -1;
 	}
 	return 0;
@@ -101,7 +101,7 @@
 				   .buf = val, .len = 1} };
 
 	if (i2c_transfer(adapter, msgs, 2) != 2) {
-		pr_err("error in i2c_read_reg\n");
+		dev_err(&adapter->dev, "error in i2c_read_reg\n");
 		return -1;
 	}
 	return 0;
@@ -111,12 +111,12 @@
 		    u8 reg, u8 *data, u16 n)
 {
 	struct i2c_msg msgs[2] = {{.addr = adr, .flags = 0,
-				   .buf = &reg, .len = 1},
-				  {.addr = adr, .flags = I2C_M_RD,
-				   .buf = data, .len = n} };
-	
+				 .buf = &reg, .len = 1},
+				{.addr = adr, .flags = I2C_M_RD,
+				 .buf = data, .len = n} };
+
 	if (i2c_transfer(adapter, msgs, 2) != 2) {
-		pr_err("error in i2c_read\n");
+		dev_err(&adapter->dev, "error in i2c_read\n");
 		return -1;
 	}
 	return 0;
@@ -133,9 +133,8 @@
 
 		while (n) {
 			int len = n;
-			
-			if (ci->cfg.max_i2c &&
-			    len > ci->cfg.max_i2c)
+
+			if (ci->cfg.max_i2c && (len > ci->cfg.max_i2c))
 				len = ci->cfg.max_i2c;
 			status = i2c_read(ci->i2c, ci->cfg.adr, 1, data, len);
 			if (status)
@@ -173,7 +172,7 @@
 	if (!status) {
 		u8 buf[256] = {3};
 
-		memcpy(buf + 1, data, n);
+		memcpy(buf+1, data, n);
 		status = i2c_write(ci->i2c, ci->cfg.adr, buf, n+1);
 	}
 	return status;
@@ -202,35 +201,6 @@
 	return status;
 }
 
-#if 0
-static int read_io_data(struct cxd *ci, u8 *data, u16 n)
-{
-	int status;
-	u8 addr[3] = { 2, 0, 0 };
-
-	status = i2c_write(ci->i2c, ci->cfg.adr, addr, 3);
-	if (!status)
-		status = i2c_read(ci->i2c, ci->cfg.adr, 3, data, n);
-	return 0;
-}
-
-static int write_io_data(struct cxd *ci, u8 *data, u16 n)
-{
-	int status;
-	u8 addr[3] = {2, 0, 0};
-
-	status = i2c_write(ci->i2c, ci->cfg.adr, addr, 3);
-	if (!status) {
-		u8 buf[256] = {3};
-
-		memcpy(buf + 1, data, n);
-		status = i2c_write(ci->i2c, ci->cfg.adr, buf, n + 1);
-	}
-	return 0;
-
-}
-#endif
-
 static int write_regm(struct cxd *ci, u8 reg, u8 val, u8 mask)
 {
 	int status = 0;
@@ -263,17 +233,14 @@
 		status = i2c_write_reg(ci->i2c, ci->cfg.adr, 0, adr);
 	if (status)
 		return status;
-	printk("write_block %d\n", n);
 
 	ci->lastaddress = adr;
 	buf[0] = 1;
 	while (n) {
 		int len = n;
-		
-		if (ci->cfg.max_i2c &&
-		    len + 1 > ci->cfg.max_i2c)
+
+		if (ci->cfg.max_i2c && (len + 1 > ci->cfg.max_i2c))
 			len = ci->cfg.max_i2c - 1;
-		printk("write %d\n", len);
 		memcpy(buf + 1, data, len);
 		status = i2c_write(ci->i2c, ci->cfg.adr, buf, len + 1);
 		if (status)
@@ -318,7 +285,7 @@
 		if (!ci->en.read_data)
 			return;
 		ci->write_busy = 0;
-		pr_info("enable cam buffer mode\n");
+		dev_info(&ci->i2c->dev, "enable cam buffer mode\n");
 		write_reg(ci, 0x0d, 0x00);
 		write_reg(ci, 0x0e, 0x01);
 		write_regm(ci, 0x08, 0x40, 0x40);
@@ -331,8 +298,6 @@
 	ci->cammode = mode;
 }
 
-#define CHK_ERROR(s) if ((status = s)) break
-
 static int init(struct cxd *ci)
 {
 	int status;
@@ -340,67 +305,140 @@
 	mutex_lock(&ci->lock);
 	ci->mode = -1;
 	do {
-		CHK_ERROR(write_reg(ci, 0x00, 0x00));
-		CHK_ERROR(write_reg(ci, 0x01, 0x00));
-		CHK_ERROR(write_reg(ci, 0x02, 0x10));
-		CHK_ERROR(write_reg(ci, 0x03, 0x00));
-		CHK_ERROR(write_reg(ci, 0x05, 0xFF));
-		CHK_ERROR(write_reg(ci, 0x06, 0x1F));
-		CHK_ERROR(write_reg(ci, 0x07, 0x1F));
-		CHK_ERROR(write_reg(ci, 0x08, 0x28));
-		CHK_ERROR(write_reg(ci, 0x14, 0x20));
+		status = write_reg(ci, 0x00, 0x00);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x01, 0x00);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x02, 0x10);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x03, 0x00);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x05, 0xFF);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x06, 0x1F);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x07, 0x1F);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x08, 0x28);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x14, 0x20);
+		if (status < 0)
+			break;
 
 		/* TOSTRT = 8, Mode B (gated clock), falling Edge,
-		   Serial, POL=HIGH, MSB */
-		CHK_ERROR(write_reg(ci, 0x0A, 0xA7));
-
-		CHK_ERROR(write_reg(ci, 0x0B, 0x33));
-		CHK_ERROR(write_reg(ci, 0x0C, 0x33));
-
-		CHK_ERROR(write_regm(ci, 0x14, 0x00, 0x0F));
-		CHK_ERROR(write_reg(ci, 0x15, ci->clk_reg_b));
-		CHK_ERROR(write_regm(ci, 0x16, 0x00, 0x0F));
-		CHK_ERROR(write_reg(ci, 0x17, ci->clk_reg_f));
+		 * Serial, POL=HIGH, MSB
+		 */
+		status = write_reg(ci, 0x0A, 0xA7);
+		if (status < 0)
+			break;
+
+		status = write_reg(ci, 0x0B, 0x33);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x0C, 0x33);
+		if (status < 0)
+			break;
+
+		status = write_regm(ci, 0x14, 0x00, 0x0F);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x15, ci->clk_reg_b);
+		if (status < 0)
+			break;
+		status = write_regm(ci, 0x16, 0x00, 0x0F);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x17, ci->clk_reg_f);
+		if (status < 0)
+			break;
 
 		if (ci->cfg.clock_mode == 2) {
 			/* bitrate*2^13/ 72000 */
 			u32 reg = ((ci->cfg.bitrate << 13) + 71999) / 72000;
-			
+
 			if (ci->cfg.polarity) {
-				CHK_ERROR(write_reg(ci, 0x09, 0x6f));
+				status = write_reg(ci, 0x09, 0x6f);
+				if (status < 0)
+					break;
 			} else {
-				CHK_ERROR(write_reg(ci, 0x09, 0x6d));
+				status = write_reg(ci, 0x09, 0x6d);
+				if (status < 0)
+					break;
 			}
-			CHK_ERROR(write_reg(ci, 0x20, 0x08));
-			CHK_ERROR(write_reg(ci, 0x21, (reg >> 8) & 0xff));
-			CHK_ERROR(write_reg(ci, 0x22, reg & 0xff));
+			status = write_reg(ci, 0x20, 0x08);
+			if (status < 0)
+				break;
+			status = write_reg(ci, 0x21, (reg >> 8) & 0xff);
+			if (status < 0)
+				break;
+			status = write_reg(ci, 0x22, reg & 0xff);
+			if (status < 0)
+				break;
 		} else if (ci->cfg.clock_mode == 1) {
 			if (ci->cfg.polarity) {
-				CHK_ERROR(write_reg(ci, 0x09, 0x6f)); /* D */
+				status = write_reg(ci, 0x09, 0x6f); /* D */
+				if (status < 0)
+					break;
 			} else {
-				CHK_ERROR(write_reg(ci, 0x09, 0x6d));
+				status = write_reg(ci, 0x09, 0x6d);
+				if (status < 0)
+					break;
 			}
-			CHK_ERROR(write_reg(ci, 0x20, 0x68));
-			CHK_ERROR(write_reg(ci, 0x21, 0x00));
-			CHK_ERROR(write_reg(ci, 0x22, 0x02));
+			status = write_reg(ci, 0x20, 0x68);
+			if (status < 0)
+				break;
+			status = write_reg(ci, 0x21, 0x00);
+			if (status < 0)
+				break;
+			status = write_reg(ci, 0x22, 0x02);
+			if (status < 0)
+				break;
 		} else {
 			if (ci->cfg.polarity) {
-				CHK_ERROR(write_reg(ci, 0x09, 0x4f)); /* C */
+				status = write_reg(ci, 0x09, 0x4f); /* C */
+				if (status < 0)
+					break;
 			} else {
-				CHK_ERROR(write_reg(ci, 0x09, 0x4d));
+				status = write_reg(ci, 0x09, 0x4d);
+				if (status < 0)
+					break;
 			}
-			CHK_ERROR(write_reg(ci, 0x20, 0x28));
-			CHK_ERROR(write_reg(ci, 0x21, 0x00));
-			CHK_ERROR(write_reg(ci, 0x22, 0x07));
+			status = write_reg(ci, 0x20, 0x28);
+			if (status < 0)
+				break;
+			status = write_reg(ci, 0x21, 0x00);
+			if (status < 0)
+				break;
+			status = write_reg(ci, 0x22, 0x07);
+			if (status < 0)
+				break;
 		}
 
-		CHK_ERROR(write_regm(ci, 0x20, 0x80, 0x80));
-		CHK_ERROR(write_regm(ci, 0x03, 0x02, 0x02));
-		CHK_ERROR(write_reg(ci, 0x01, 0x04));
-		CHK_ERROR(write_reg(ci, 0x00, 0x31));
+		status = write_regm(ci, 0x20, 0x80, 0x80);
+		if (status < 0)
+			break;
+		status = write_regm(ci, 0x03, 0x02, 0x02);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x01, 0x04);
+		if (status < 0)
+			break;
+		status = write_reg(ci, 0x00, 0x31);
+		if (status < 0)
+			break;
 
 		/* Put TS in bypass */
-		CHK_ERROR(write_regm(ci, 0x09, 0x08, 0x08));
+		status = write_regm(ci, 0x09, 0x08, 0x08);
+		if (status < 0)
+			break;
 		ci->cammode = -1;
 		cam_mode(ci, 0);
 	} while (0);
@@ -413,23 +451,6 @@
 			      int slot, int address)
 {
 	struct cxd *ci = ca->data;
-#if 0
-	if (ci->amem_read) {
-		if (address <= 0 || address > 1024)
-			return -EIO;
-		return ci->amem[address];
-	}
-
-	mutex_lock(&ci->lock);
-	write_regm(ci, 0x06, 0x00, 0x05);
-	read_pccard(ci, 0, &ci->amem[0], 128);
-	read_pccard(ci, 128, &ci->amem[0], 128);
-	read_pccard(ci, 256, &ci->amem[0], 128);
-	read_pccard(ci, 384, &ci->amem[0], 128);
-	write_regm(ci, 0x06, 0x05, 0x05);
-	mutex_unlock(&ci->lock);
-	return ci->amem[address];
-#else
 	u8 val;
 
 	mutex_lock(&ci->lock);
@@ -437,7 +458,6 @@
 	read_pccard(ci, address, &val, 1);
 	mutex_unlock(&ci->lock);
 	return val;
-#endif
 }
 
 static int write_attribute_mem(struct dvb_ca_en50221 *ca, int slot,
@@ -485,46 +505,24 @@
 		read_data(ca, slot, ci->rbuf, 0);
 
 	mutex_lock(&ci->lock);
-#if 0
-	write_reg(ci, 0x00, 0x21);
-	write_reg(ci, 0x06, 0x1F);
-	write_reg(ci, 0x00, 0x31);
-#else
-#if 0
-	write_reg(ci, 0x06, 0x1F);
-	write_reg(ci, 0x06, 0x2F);
-#else
 	cam_mode(ci, 0);
 	write_reg(ci, 0x00, 0x21);
 	write_reg(ci, 0x06, 0x1F);
-	/*msleep(300);*/
 	write_reg(ci, 0x00, 0x31);
 	write_regm(ci, 0x20, 0x80, 0x80);
 	write_reg(ci, 0x03, 0x02);
 	ci->ready = 0;
-#endif
-#endif
 	ci->mode = -1;
 	{
 		int i;
-#if 0
-		u8 val;
-#endif
+
 		for (i = 0; i < 100; i++) {
-			msleep(20);
-#if 0
-			read_reg(ci, 0x06, &val);
-			pr_info(KERN_INFO "%d:%02x\n", i, val);
-			if (!(val&0x10))
-				break;
-#else
+			usleep_range(10000, 11000);
 			if (ci->ready)
 				break;
-#endif
 		}
 	}
 	mutex_unlock(&ci->lock);
-	/* msleep(500); */
 	return 0;
 }
 
@@ -532,7 +530,7 @@
 {
 	struct cxd *ci = ca->data;
 
-	pr_info("slot_shutdown\n");
+	dev_info(&ci->i2c->dev, "slot_shutdown\n");
 	if (ci->cammode)
 		read_data(ca, slot, ci->rbuf, 0);
 	mutex_lock(&ci->lock);
@@ -572,18 +570,20 @@
 		return 0;
 	write_reg(ci, 0x05, istat);
 
-	if (istat & 0x40)
+	if (istat&0x40)
 		ci->dr = 1;
-	if (istat & 0x20)
+
+	if (istat&0x20)
 		ci->write_busy = 0;
-	if (istat & 2) {
+
+	if (istat&2) {
 		u8 slotstat;
 
 		read_reg(ci, 0x01, &slotstat);
-		if (!(2 & slotstat)) {
+		if (!(2&slotstat)) {
 			if (!ci->slot_stat) {
 				ci->slot_stat |=
-					DVB_CA_EN50221_POLL_CAM_PRESENT;
+					      DVB_CA_EN50221_POLL_CAM_PRESENT;
 				write_regm(ci, 0x03, 0x08, 0x08);
 			}
 
@@ -591,11 +591,11 @@
 			if (ci->slot_stat) {
 				ci->slot_stat = 0;
 				write_regm(ci, 0x03, 0x00, 0x08);
-				pr_info("NO CAM\n");
+				dev_info(&ci->i2c->dev, "NO CAM\n");
 				ci->ready = 0;
 			}
 		}
-		if ((istat & 8) &&
+		if ((istat&8) &&
 		    (ci->slot_stat == DVB_CA_EN50221_POLL_CAM_PRESENT)) {
 			ci->ready = 1;
 			ci->slot_stat |= DVB_CA_EN50221_POLL_CAM_READY;
@@ -644,16 +644,6 @@
 	read_block(ci, 0x12, ebuf, len);
 	ci->dr = 0;
 	mutex_unlock(&ci->lock);
-#if 0
-	pr_info("read_data %d\n", len);
-	{
-		int i;
-
-		for (i = 0; i < len; i++)
-			pr_info("%02x ", ebuf[i]);
-		pr_info("\n");
-	}
-#endif
 	return len;
 }
 
@@ -666,8 +656,8 @@
 	if (ci->write_busy)
 		return -EAGAIN;
 	mutex_lock(&ci->lock);
-	write_reg(ci, 0x0d, ecount >> 8);
-	write_reg(ci, 0x0e, ecount & 0xff);
+	write_reg(ci, 0x0d, ecount>>8);
+	write_reg(ci, 0x0e, ecount&0xff);
 	write_block(ci, 0x11, ebuf, ecount);
 	ci->write_busy = 1;
 	mutex_unlock(&ci->lock);
@@ -688,35 +678,36 @@
 	.read_data           = read_data,
 	.write_data          = write_data,
 #endif
+
 };
 
 struct dvb_ca_en50221 *cxd2099_attach(struct cxd2099_cfg *cfg,
 				      void *priv,
 				      struct i2c_adapter *i2c)
 {
-	struct cxd *ci = 0;
+	struct cxd *ci;
 	u8 val;
 
 	if (i2c_read_reg(i2c, cfg->adr, 0, &val) < 0) {
-		pr_info("No CXD2099 detected at %02x\n", cfg->adr);
-		return 0;
+		dev_info(&i2c->dev, "No CXD2099 detected at %02x\n", cfg->adr);
+		return NULL;
 	}
 
 	ci = kzalloc(sizeof(struct cxd), GFP_KERNEL);
 	if (!ci)
-		return 0;
+		return NULL;
 
 	mutex_init(&ci->lock);
-	memcpy(&ci->cfg, cfg, sizeof(struct cxd2099_cfg));
+	ci->cfg = *cfg;
 	ci->i2c = i2c;
 	ci->lastaddress = 0xff;
 	ci->clk_reg_b = 0x4a;
 	ci->clk_reg_f = 0x1b;
 
-	memcpy(&ci->en, &en_templ, sizeof(en_templ));
+	ci->en = en_templ;
 	ci->en.data = ci;
 	init(ci);
-	pr_info("Attached CXD2099AR at %02x\n", ci->cfg.adr);
+	dev_info(&i2c->dev, "Attached CXD2099AR at %02x\n", ci->cfg.adr);
 	return &ci->en;
 }
 EXPORT_SYMBOL(cxd2099_attach);
diff -Naur dddvb-0.9.28.v7a.0yavdr0_sav/frontends/cxd2099.h dddvb-0.9.28.v7a.0yavdr0/frontends/cxd2099.h
--- dddvb-0.9.28.v7a.0yavdr0_sav/frontends/cxd2099.h	2017-03-17 20:53:46.000000000 +0100
+++ dddvb-0.9.28.v7a.0yavdr0/frontends/cxd2099.h	2017-05-06 14:23:33.000000000 +0200
@@ -36,8 +36,18 @@
 	u32 max_i2c;
 };
 
+#if defined(CONFIG_DVB_CXD2099) || \
+	(defined(CONFIG_DVB_CXD2099_MODULE) && defined(MODULE))
 struct dvb_ca_en50221 *cxd2099_attach(struct cxd2099_cfg *cfg,
 				      void *priv, struct i2c_adapter *i2c);
+#else
 
+static inline struct dvb_ca_en50221 *cxd2099_attach(struct cxd2099_cfg *cfg,
+					void *priv, struct i2c_adapter *i2c)
+{
+	dev_warn(&i2c->dev, "%s: driver disabled by Kconfig\n", __func__);
+	return NULL;
+}
+#endif
 
 #endif
